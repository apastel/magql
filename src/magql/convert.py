"""
GQLMagic converts a dictionary of SQLAlchemy tables into a generic GraphQL
Schema. Each table has 3 autogenerated mutations, create, update, and delete,
and 2 autogenerated queries, single and many. Each mutation has a marshmallow
schema automatically generated for it based on the types of its fields.
The validations can be overridden with decorators, as explained later.
"""
from collections import namedtuple

from graphql import GraphQLArgument
from graphql import GraphQLEnumType
from graphql import GraphQLField
from graphql import GraphQLInputField
from graphql import GraphQLInputObjectType
from graphql import GraphQLList
from graphql import GraphQLNonNull
from graphql import GraphQLObjectType
from graphql import GraphQLScalarType
from graphql import GraphQLSchema
from graphql import GraphQLString
from graphql import GraphQLInt
from graphql import GraphQLID
from graphql import GraphQLUnionType
from inflection import camelize
from inflection import pluralize
from marshmallow_sqlalchemy import ModelSchema
from sqlalchemy_utils import get_mapper

from magql.filter import RelFilter
from magql.get_type import get_filter_type
from magql.get_type import get_required_type
from magql.get_type import get_type
from magql.resolver_factory import CamelResolver
from magql.resolver_factory import CheckDeleteResolver
from magql.resolver_factory import CheckDeleteUnionResolver
from magql.resolver_factory import CreateResolver
from magql.resolver_factory import DeleteResolver
from magql.resolver_factory import EnumResolver
from magql.resolver_factory import ManyResolver
from magql.resolver_factory import Resolver
from magql.resolver_factory import SingleResolver
from magql.resolver_factory import UpdateResolver
from magql.validator import get_validator_overrides


def js_camelize(word):
    # add config check
    # disable while camelcasing resolvers aren't added
    return camelize(word, False)


def get_tables(db):
    try:
        return db.metadata.tables
    except AttributeError:
        print("Could not find database tables")


tuple_types = [
    "object",
    "filter",
    "sort",
    "input",
    "required_input",
    "payload",
    "schema",
]
GraphQLObjectTypes = namedtuple("GQLObjectTypes", tuple_types)


def is_rel_required(rel):
    calc_keys = rel._calculated_foreign_keys
    fk = rel._user_defined_foreign_keys.union(calc_keys).pop()
    return not fk.nullable


class MagqlSchema:
    """
     Creates a subclass of GraphQLSchema which has been extended to
     provide the capability to override resolvers. Takes in SQLAlchemy
     tables, taken from the metadata of a SQLAlchemy declarative base.

    :param tables: A dict with values of each table to generate a Schema
            for and keys of the tablename
    """

    def __init__(self, tables, existing_schema=None):
        query_fields = {}
        mutation_fields = {}
        self.table_types = {}

        # make query columns and mutations
        for table_name, table in tables.items():
            try:
                get_mapper(table)
            except ValueError:
                print(f"No Mapper for table {table.name}")
                continue
            # Build only columns first so
            # GQLObjectTypes are built for all tables
            self.generate_column_object_types(table_name, table)

            # Then add resolvers
            mutation_fields = {
                **mutation_fields,
                **self.generate_mutations(table_name, table),
            }

            query_fields = {
                **query_fields,
                **self.generate_column_queries(table_name, table),
            }

        for _table_name, table in tables.items():
            try:
                table_mapper = get_mapper(table)
            except ValueError:
                print(f"No Mapper for table {table.name}")
                continue

            for rel_name, rel in table_mapper.relationships.items():
                direction = rel.direction.name
                required = is_rel_required(rel)

                object = self.table_types[table].object
                input = self.table_types[table].input
                required_input = self.table_types[table].required_input
                filter_ = self.table_types[table].filter

                # rel_object is used for queries so it must be recursive
                rel_object = self.table_types[rel.target].object

                # inputs are for mutations so should not be recursive
                rel_input = GraphQLInt
                rel_required_input = GraphQLInt

                if "TOMANY" in direction:
                    rel_object = GraphQLList(rel_object)
                    rel_input = GraphQLList(rel_input)
                    rel_required_input = GraphQLList(rel_required_input)
                # 'TOMANY' cannot be required
                elif required:
                    rel_required_input = GraphQLNonNull(rel_required_input)

                rel_name = js_camelize(rel_name)

                required_input.fields[rel_name] = GraphQLInputField(
                    rel_required_input
                )  # noqa: E501
                input.fields[rel_name] = GraphQLInputField(rel_input)
                object.fields[rel_name] = GraphQLField(
                    rel_object, None, Resolver()
                )  # noqa: E501
                filter_.fields[rel_name] = GraphQLInputField(RelFilter)

        types = [types.object for _, types in self.table_types.items()]

        query_fields["checkDelete"] = GraphQLField(
            GraphQLList(
                GraphQLUnionType(
                    "CheckDeleteUnion",
                    types,
                    CheckDeleteUnionResolver(self.table_types),
                )
            ),
            {
                "tableName": GraphQLArgument(GraphQLString),
                "id": GraphQLArgument(GraphQLString),
            },
            CheckDeleteResolver(self.table_types),
        )
        query = GraphQLObjectType("Query", query_fields)
        mutation = GraphQLObjectType("Mutation", mutation_fields)

        self.schema = GraphQLSchema(query, mutation)

        if existing_schema is not None:
            self.merge_schema(existing_schema)

    def generate_column_object_types(self, table_name, table):
        fields, filter_fields, sort_fields, required_input_fields, input_fields = self.build_fields_from_column(  # noqa: E501
            table
        )

        try:
            table_class = get_mapper(table).class_
        except ValueError:
            print(table)
            return

        schema_overrides = get_validator_overrides(table_class)
        schema_overrides["Meta"] = type(
            "Meta", (object,), {"model": table_class}
        )  # noqa: E501

        camelized = camelize(table.name)
        gql_object = GraphQLObjectType(camelized, fields)
        self.table_types[table] = GraphQLObjectTypes(
            object=gql_object,
            filter=GraphQLInputObjectType(camelized + "Filter", filter_fields),
            sort=GraphQLEnumType(camelized + "Sort", sort_fields),
            input=GraphQLInputObjectType(camelized + "Input", input_fields),
            required_input=GraphQLInputObjectType(
                camelized + "InputRequired", required_input_fields
            ),
            payload=GraphQLNonNull(
                GraphQLObjectType(
                    camelized + "Payload",
                    {
                        "error": GraphQLList(GraphQLString),
                        camelize(table.name, False): gql_object,
                    },
                )
            ),
            schema=type(
                camelized + "Schema", (ModelSchema,), schema_overrides
            ),  # noqa: E501
        )

    def build_fields_from_column(self, table):
        fields = {}
        required_input_fields = {}
        input_fields = {}
        filter_fields = {}
        sort_fields = {}
        for column_name, column in table.c.items():
            if column.foreign_keys:
                pass
            else:
                column_name = js_camelize(column_name)

                base_type = get_type(column)
                fields[column_name] = GraphQLField(
                    base_type, None, CamelResolver()
                )  # noqa: E501

                # TODO: Refactor how enums are handled
                if isinstance(base_type, GraphQLEnumType):
                    fields[column_name].resolve = EnumResolver()
                required_input_fields[column_name] = GraphQLInputField(
                    get_required_type(column, base_type)
                )
                input_fields[column_name] = GraphQLInputField(base_type)
                filter_fields[column_name] = get_filter_type(column, base_type)
                sort_fields[column_name + "_asc"] = (column_name + "_asc",)
                sort_fields[column_name + "_desc"] = (column_name + "_desc",)

        return (
            fields,
            filter_fields,
            sort_fields,
            required_input_fields,
            input_fields,
        )  # noqa: E501

    def generate_mutations(self, table_name, table):

        required_input = self.table_types[table].required_input
        input = self.table_types[table].input
        payload = self.table_types[table].payload
        schema = self.table_types[table].schema
        fields = {}

        id_arg = GraphQLArgument(GraphQLNonNull(GraphQLString))
        input_arg = GraphQLArgument(GraphQLNonNull(input))
        required_input_arg = GraphQLArgument(GraphQLNonNull(required_input))

        create_args = {"input": required_input_arg}

        update_args = {"input": input_arg}

        delete_args = {"id": id_arg}
        camelized = camelize(table_name)
        fields["create" + camelized] = GraphQLField(
            payload, create_args, CreateResolver(table, schema)
        )
        fields["update" + camelized] = GraphQLField(
            payload, update_args, UpdateResolver(table, schema)
        )
        fields["delete" + camelized] = GraphQLField(
            payload, delete_args, DeleteResolver(table, schema)
        )

        return fields

    def generate_column_queries(self, table_name, table):

        table_gql_object = self.table_types[table].object
        filter_obj = self.table_types[table].filter
        sort_obj = self.table_types[table].sort
        fields = {
            js_camelize(table_name): GraphQLField(
                table_gql_object,
                {"id": GraphQLArgument(GraphQLNonNull(GraphQLID))},
                SingleResolver(table),
            ),
            js_camelize(pluralize(table_name)): GraphQLField(
                GraphQLList(table_gql_object),
                {
                    "filter": GraphQLArgument(filter_obj),
                    "sort": GraphQLArgument(
                        GraphQLList(GraphQLNonNull(sort_obj))
                    ),  # noqa: E501
                },
                ManyResolver(table),
            ),
        }
        return fields

    @staticmethod
    def join_types(type1, type2):
        new_fields = {**type1.fields, **type2.fields}  # type2 replaces type1

        return GraphQLObjectType(type1.name, new_fields)

    @staticmethod
    def get_merged_type(return_type, joined_type_map):
        if isinstance(return_type, GraphQLList):
            return GraphQLList(
                MagqlSchema.get_merged_type(
                    return_type.of_type, joined_type_map
                )  # noqa: E501
            )

        if isinstance(return_type, GraphQLNonNull):
            return GraphQLNonNull(
                MagqlSchema.get_merged_type(
                    return_type.of_type, joined_type_map
                )  # noqa: E501
            )

        type_name = return_type.name

        if type_name in joined_type_map:
            return_type = joined_type_map[type_name]

        return return_type

    @staticmethod
    def convert_old_union_type_resolver(old_resolver, joined_type_map):
        """
        When merging schema's the type resolver for unions cannot be
        updated at the time of the merge. Instead wrap the resolver with
        a function that will convert the old type to the new type,
        if there is a new type
        :param old_resolver:
        :param joined_type_map:
        :return:
        """

        def new_resolver(self, parent, info, *args, **kwargs):
            old_value = old_resolver(self, parent, info, *args, **kwargs)
            return MagqlSchema.get_merged_type(old_value, joined_type_map)

        return new_resolver

    @staticmethod
    def update_return_type(return_type, joined_type_map):

        if isinstance(return_type, GraphQLList):
            return GraphQLList(
                MagqlSchema.update_return_type(
                    return_type.of_type, joined_type_map
                )  # noqa: E501
            )

        if isinstance(return_type, GraphQLNonNull):
            updated_return_type = MagqlSchema.update_return_type(
                return_type.of_type, joined_type_map
            )
            return GraphQLNonNull(updated_return_type)

        if isinstance(return_type, GraphQLUnionType):
            types = [
                MagqlSchema.get_merged_type(type_, joined_type_map)
                for type_ in return_type.types
            ]
            return GraphQLUnionType(
                return_type.name,
                types,
                MagqlSchema.convert_old_union_type_resolver(
                    return_type.resolve_type, joined_type_map
                ),
                return_type.description,
                return_type.ast_node,
                return_type.extension_ast_nodes,
            )

        type_name = return_type.name
        if type_name in joined_type_map:
            return_type = joined_type_map[type_name]

        new_sub_fields = {}
        for field_name, field in return_type.fields.items():
            new_sub_fields[field_name] = field
            if MagqlSchema.get_object_type(field.type).name in joined_type_map:
                new_sub_fields[field_name].type = MagqlSchema.get_merged_type(
                    field.type, joined_type_map
                )
        return_type.fields = new_sub_fields
        return return_type

    @staticmethod
    def get_object_type(field):
        while not getattr(field, "name", None):
            field = field.of_type
        return field

    @staticmethod
    def generate_new_field(field, joined_type_map):
        type_ = MagqlSchema.update_return_type(field.type, joined_type_map)

        return GraphQLField(
            type_,
            field.args,
            field.resolve,
            field.subscribe,
            field.description,
            field.deprecation_reason,
        )

    def merge_schema(self, schema):
        assert isinstance(schema, GraphQLSchema)

        joined_type_map = {}
        for type_name, type in schema.type_map.items():
            if (
                type_name in self.schema.type_map
                and not isinstance(type, GraphQLScalarType)
                and not type_name.startswith("__")
            ):
                joined_type_map[type_name] = MagqlSchema.join_types(
                    self.schema.type_map[type_name], type
                )

        new_query_fields = {}
        new_mut_fields = {}

        self_queries = getattr(self.schema.query_type, "fields", {})
        for query_name, field in self_queries.items():
            new_query_fields[query_name] = MagqlSchema.generate_new_field(
                field, joined_type_map
            )
        schema_queries = getattr(schema.query_type, "fields", {})
        for query_name, field in schema_queries.items():
            new_query_fields[query_name] = MagqlSchema.generate_new_field(
                field, joined_type_map
            )

        self_mutations = getattr(self.schema.mutation_type, "fields", {})
        for mutation_name, field in self_mutations.items():
            new_mut_fields[mutation_name] = MagqlSchema.generate_new_field(
                field, joined_type_map
            )
        schema_mutations = getattr(schema.mutation_type, "fields", {})
        for mutation_name, field in schema_mutations.items():
            new_mut_fields[mutation_name] = MagqlSchema.generate_new_field(
                field, joined_type_map
            )

        new_query = GraphQLObjectType("Query", new_query_fields)
        new_mutation = GraphQLObjectType("Mutation", new_mut_fields)
        self.schema = GraphQLSchema(new_query, new_mutation)

    """
    Subclass of GraphQLSchema that allows the overriding of
    """

    def override_resolver(self, field_name, resolver):
        if field_name in self.schema.mutation_type.fields:
            self.schema.mutation_type.fields[field_name].resolve = resolver
        elif field_name in self.schema.query_type.fields:
            self.schema.query_type.fields[field_name].resolve = resolver

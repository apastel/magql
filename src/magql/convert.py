"""
GQLMagic converts a dictionary of SQLAlchemy tables into a generic GraphQL
Schema. Each table has 3 autogenerated mutations, create, update, and delete,
and 2 autogenerated queries, single and many. Each mutation has a marshmallow
schema automatically generated for it based on the types of its fields.
The validations can be overridden with decorators, as explained later.
"""
from magql.validator import get_validator_overrides
from graphql import GraphQLSchema, GraphQLField, GraphQLObjectType, GraphQLList, GraphQLNonNull, \
    GraphQLString, GraphQLInputField, GraphQLArgument, GraphQLID, GraphQLInputObjectType, GraphQLEnumType
from marshmallow_sqlalchemy import ModelSchema
from sqlalchemy_utils import get_mapper
from magql.get_type import get_type, get_required_type, get_filter_type
from magql.resolver_factory import Resolver, ManyResolver, SingleResolver, CreateResolver, UpdateResolver, DeleteResolver
from magql.filter import RelFilter
from inflection import pluralize, camelize
from collections import namedtuple


def get_tables(db):
    try:
        return db.metadata.tables
    except AttributeError:
        print("Could not find database tables")


table_to_gql_object_types = {}
GraphQLObjectTypes = namedtuple('GQLObjectTypes', ['object', 'filter', 'sort', 'input', 'required_input', 'payload', 'schema'])


def build_fields_from_column(table):
    fields = {}
    required_input_fields = {}
    input_fields = {}
    filter_fields = {}
    sort_fields = {}
    for column_name, column in table.c.items():
        if column.foreign_keys:
            pass
        else:
            fields[column_name] = GraphQLField(get_type(column.type))
            required_input_fields[column_name] = GraphQLInputField(get_required_type(column))
            input_fields[column_name] = GraphQLInputField(get_type(column.type))
            filter_fields[column_name] = get_filter_type(column.type)
            sort_fields[column_name + "_asc"] = column_name + "_asc",
            sort_fields[column_name + "_desc"] = column_name + "_desc",

    return fields, filter_fields, sort_fields, required_input_fields, input_fields


def generate_mutations(table_name, table):

    required_input = table_to_gql_object_types[table].required_input
    input = table_to_gql_object_types[table].input
    payload = table_to_gql_object_types[table].payload
    schema = table_to_gql_object_types[table].schema
    fields = {}

    id_arg = GraphQLArgument(GraphQLNonNull(GraphQLID))
    input_arg = GraphQLArgument(GraphQLNonNull(input))
    required_input_arg = GraphQLArgument(GraphQLNonNull(required_input))

    create_args = {
        "input": required_input_arg
    }

    update_args = {
        "id": id_arg,
        "input": input_arg
    }

    delete_args = {
        "id": id_arg,
    }
    camelized = camelize(table_name)
    fields["create" + camelized] = GraphQLField(payload, create_args, CreateResolver(table, schema))
    fields["update" + camelized] = GraphQLField(payload, update_args, UpdateResolver(table, schema))
    fields["delete" + camelized] = GraphQLField(payload, delete_args, DeleteResolver(table, schema))

    return fields


def generate_column_queries(table_name, table):

    table_gql_object = table_to_gql_object_types[table].object
    filter_obj = table_to_gql_object_types[table].filter
    sort_obj = table_to_gql_object_types[table].sort
    fields = {
        table_name: GraphQLField(
            table_gql_object,
            {"id": GraphQLArgument(GraphQLNonNull(GraphQLID))},
            SingleResolver(table)
        ),
        pluralize(table_name): GraphQLField(
            GraphQLList(table_gql_object),
            {
                "filter": GraphQLArgument(filter_obj),
                "sort": GraphQLArgument(GraphQLList(GraphQLNonNull(sort_obj)))
            },
            ManyResolver(table)
        )
    }
    return fields


def generate_column_object_types(table_name, table):
    fields, filter_fields, sort_fields, required_input_fields, input_fields = build_fields_from_column(table)

    table_class = get_mapper(table).class_
    schema_overrides = get_validator_overrides(table_class)
    schema_overrides["Meta"] = type("Meta", (object, ), {
                "model": table_class,
            })

    camelized = camelize(table.name)
    gql_object = GraphQLObjectType(camelized, fields)
    table_to_gql_object_types[table] = GraphQLObjectTypes(
        object=gql_object,
        filter=GraphQLInputObjectType(camelized + "Filter", filter_fields),
        sort=GraphQLEnumType(camelized + 'Sort', sort_fields),
        input=GraphQLInputObjectType(camelized + "Input", input_fields),
        required_input=GraphQLInputObjectType(camelized + "InputRequired", required_input_fields),
        payload=GraphQLNonNull(GraphQLObjectType(camelized + "Payload", {
            'error': GraphQLList(GraphQLString),
            table_name: gql_object
        })),
        schema=type(camelized + "Schema", (ModelSchema,), schema_overrides)
    )


def is_rel_required(rel):
    fk = rel._user_defined_foreign_keys.union(rel._calculated_foreign_keys).pop()
    return not fk.nullable


class GeneratedGraphQLSchema(GraphQLSchema):
    """
    Subclass of GraphQLSchema that allows the overriding of
    """
    def override_resolver(self, field_name, resolver):
        if field_name in self.mutation_type.fields:
            self.mutation_type.fields[field_name].resolve = resolver
        elif field_name in self.query_type.fields:
            self.query_type.fields[field_name].resolve = resolver


def convert(tables):
    """
     Returns a subclass of GraphQLSchema which has been extended to
     provide the capability to override resolvers. Takes in SQLAlchemy
     tables, taken form the metadata of a SQLAlchemy declarative base.

    :param tables: A dict with values of each table to generate a Schema
            for and keys of the tablename
    :return: An autogenerated GQLSchema
    """
    # tables = get_tables(db)

    query_fields = {}
    mutation_fields = {}

    # make query columns and mutations
    for table_name, table in tables.items():

        # Build only columns first so GQLObjectTypes are built for all tables
        generate_column_object_types(table_name, table)

        # Then add resolvers
        mutation_fields = {**mutation_fields, **generate_mutations(table_name, table)}

        query_fields = {**query_fields, **generate_column_queries(table_name, table)}

    for table_name, table in tables.items():
        table_mapper = get_mapper(table)

        for relationship_name, rel in table_mapper.relationships.items():
            direction = rel.direction.name
            required = is_rel_required(rel)

            object = table_to_gql_object_types[table].object
            input = table_to_gql_object_types[table].input
            required_input = table_to_gql_object_types[table].required_input
            filter_ = table_to_gql_object_types[table].filter

            # rel_object is used for queries so it must be recursive
            rel_object = table_to_gql_object_types[rel.target].object

            # inputs are for mutations so should not be recursive
            rel_input = GraphQLID
            rel_required_input = GraphQLID

            if 'TOMANY' in direction:
                rel_object = GraphQLList(rel_object)
                rel_input = GraphQLList(rel_input)
                rel_required_input = GraphQLList(rel_required_input)
            # 'TOMANY' cannot be required
            elif required:
                rel_required_input = GraphQLNonNull(rel_required_input)

            required_input.fields[relationship_name] = GraphQLInputField(rel_required_input)
            input.fields[relationship_name] = GraphQLInputField(rel_input)
            object.fields[relationship_name] = GraphQLField(rel_object, None, Resolver())
            filter_.fields[relationship_name] = GraphQLInputField(RelFilter)
    query = GraphQLObjectType("Query", query_fields)
    mutation = GraphQLObjectType("Mutation", mutation_fields)

    return GeneratedGraphQLSchema(query, mutation)
